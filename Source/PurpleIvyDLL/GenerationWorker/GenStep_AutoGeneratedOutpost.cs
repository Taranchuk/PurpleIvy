using System;
using System.Collections.Generic;
using RimWorld;
using RimWorld.BaseGen;
using Verse;

namespace GenerationWorker
{
	public class GenStep_AutoGeneratedOutpost : GenStep
	{
		public override int SeedPart
		{
			get
			{
				return 398638181;
			}
		}

        public override void Generate(Map map, GenStepParams parms)
        {
        	CellRect rectToDefend;
        	if (!MapGenerator.TryGetVar<CellRect>("RectOfInterest", out rectToDefend))
        	{
        		rectToDefend = CellRect.SingleCell(map.Center);
        	}
        	Faction faction;
        	if (map.ParentFaction == null || map.ParentFaction == Faction.OfPlayer)
        	{
        		faction = Find.FactionManager.RandomEnemyFaction(false, false, true, TechLevel.Industrial);
        	}
        	else
        	{
        		faction = map.ParentFaction;
        	}
        	ResolveParams resolveParams = default(ResolveParams);
        	resolveParams.rect = this.GetOutpostRect(rectToDefend, map);
        	resolveParams.faction = faction;
        	resolveParams.edgeDefenseWidth = new int?(0);
        	resolveParams.edgeDefenseTurretsCount = new int?(Rand.RangeInclusive(0, 0));
        	resolveParams.edgeDefenseMortarsCount = new int?(0);
        	if (parms.sitePart != null)
        	{
        		resolveParams.settlementPawnGroupPoints = new float?(parms.sitePart.parms.threatPoints);
        		resolveParams.settlementPawnGroupSeed = new int?(OutpostSitePartUtility.GetPawnGroupMakerSeed(parms.sitePart.parms));
        	}
        	else
        	{
        		resolveParams.settlementPawnGroupPoints = new float?(this.defaultPawnGroupPointsRange.RandomInRange);
        	}
        	BaseGen.globalSettings.map = map;
        	BaseGen.globalSettings.minBuildings = 28;
        	BaseGen.globalSettings.minBarracks = 4;
        	BaseGen.symbolStack.Push("advancedGeneration", resolveParams);
        	BaseGen.Generate();
        }

        private CellRect GetOutpostRect(CellRect rectToDefend, Map map)
		{
			GenStep_AutoGeneratedOutpost.possibleRects.Add(new CellRect(rectToDefend.minX - 1 - this.size, rectToDefend.CenterCell.z - this.size / 2, this.size, this.size));
			GenStep_AutoGeneratedOutpost.possibleRects.Add(new CellRect(rectToDefend.maxX + 1, rectToDefend.CenterCell.z - this.size / 2, this.size, this.size));
			GenStep_AutoGeneratedOutpost.possibleRects.Add(new CellRect(rectToDefend.CenterCell.x - this.size / 2, rectToDefend.minZ - 1 - this.size, this.size, this.size));
			GenStep_AutoGeneratedOutpost.possibleRects.Add(new CellRect(rectToDefend.CenterCell.x - this.size / 2, rectToDefend.maxZ + 1, this.size, this.size));
			CellRect mapRect = new CellRect(0, 0, map.Size.x, map.Size.z);
			GenStep_AutoGeneratedOutpost.possibleRects.RemoveAll((CellRect x) => !x.FullyContainedWithin(mapRect));
			if (GenCollection.Any<CellRect>(GenStep_AutoGeneratedOutpost.possibleRects))
			{
				return GenCollection.RandomElement<CellRect>(GenStep_AutoGeneratedOutpost.possibleRects);
			}
			return rectToDefend;
		}

		public int size = 38;

		public FloatRange defaultPawnGroupPointsRange = SymbolResolver_AdvancedGeneration.DefaultPawnsPoints;

		private static List<CellRect> possibleRects = new List<CellRect>();
	}
}

